---
layout:     post
title:      语法分析程序
subtitle:   使用LL(1)文法
date:       2017-11-03
author:     Awybupt
header-img: img/page-CL.jpg
catalog: true
tags:
    - 编译原理
    - C++
---
# 语法分析程序
* 编写语法分析程序,实现对算数表达式的语法分析.
    * 表达式由如下文法产生
        * E->E+T|E-T|T
        * T->T*F|T/F|F
        * F->id|(E)|num
* 要想使用LL(1)文法必须先把文法转换为无左递归文法,无左公因子手工转换后得到如下文法
    * E->TD
    * D->+TD|-TD|e
    * T->FB
    * B->*FB|/FB|e
    * F->d|(E)|n
    
#### 分别求出如上文法的FIRST集和FOLLOW集,得到如下文法

   VN    | First | FOLLOW
------ | ------ | --------
E | d,(,n |  s,)
D | +,-,e |  s,)
T | d,(,n |  +,-
B | *,/,e |  +,-
F | d,(,n |  *,/

----------
* 然后通过这段代码构造出LL(1)分析表
```C++
void excel::gene(){
    for(auto se:TT){
        for(auto fi:se.first){
            if(fi=='e'){
                for(auto fo:se.follow){
                    analysistable.insert(pair<loc,string>(loc(se.nt,fo),"e"));
                }
            }
            else{
                int choice=0;//choice
                int temp=(int)(se.production).size();
                for(int i=0;i<temp;i++){
                    if(se.production[i][0]==fi){
                        choice=i;
                    }
                }
                analysistable.insert(pair<loc,string>(loc((se.nt),fi),se.production[choice]));
            }
        }
    }
}
```
* 通过这段代码使用分析表分析
```C++
void excel::Syntaxanalysis(string analytarget){
    analytarget=analytarget+'s';
    string stak="sE";
    do{
        char X=youzhanding(stak);
        char A=zuozhanding(analytarget);
        if(judgeVT(X))
        {
            if(X==A)
            {
                stak=youtanzhan(stak);
                analytarget=zuotanzhan(analytarget);
            }
            else{
                cout<<"error!"<<endl;
                break;
            }
        }
        else{
            string wtemp=searchgene(X, A);
            if(wtemp.size()>0){
                stak=youtanzhan(stak);
                wtemp=strrev(wtemp);
                stak=youruzhan(stak, wtemp);
                cout<<X<<"->"<<strrev(wtemp)<<endl;
                
            }
            else{
                cout<<"error!"<<endl;
                break;
            }
        }
        
    }while(!(stak=="s"&&analytarget=="s"));
}
```
* 以下是源代码
```C++
//
//  main.cpp
//  LL1
//
//  Created by 魏晓 on 11/7/17.
//  Copyright © 2017 魏晓. All rights reserved.
//

#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <iterator>
using namespace std;

typedef struct ffset{
    char nt;//NT
    vector<char> first;
    vector<char> follow;
    vector<string> production;
    ffset(char a,vector<char> b,vector<char> c,vector<string> d)
    {
        nt=a;
        first = b;
        follow = c;
        production=d;
    }
}set;
char zuozhanding(string temp)
{
    return temp[0];
}
string zuotanzhan(string temp){
    string another=temp.substr(1,temp.size()-1);
    return another;
}
string youtanzhan(string temp){
    string another=temp.substr(0,temp.size()-1);
    return another;
}
string youruzhan(string temp,string tchar){
    return temp+tchar;
}
char youzhanding(string temp){
    return temp[temp.size()-1];
}
string strrev(string str)
{
    string temp="";
    for(auto i:str){
        temp=i+temp;
    }
    return temp;
}
typedef struct location{
    char Nt;
    char t;
    location(char a,char b)
    {
        Nt=a;
        t=b;
    }
    bool operator < (const location & rhs) const
    {
        return true;
    }
}loc;

typedef struct programoutput{
    string anastack;
    string inputcomment;
    string outputcomment;
    string leftpattern;
    programoutput(string a,string b,string c,string d){
        anastack=a;
        inputcomment=b;
        outputcomment=c;
        leftpattern=d;
    }
}outp;
class excel{
private:
    vector<set> TT;
    map<loc,string> analysistable;
    map<loc,string>::iterator iter;
    std::vector<char> VN{'E','D','T','B','F'};
    std::vector<char> VT{'+','-','*','/','(',')','d','n','s'};
    vector<outp> ans;
public:
    
    excel();
    ~excel();
    void gene();//构造分析表
    string searchgene(char w,char m);//查找分析表
    void displaygene();//显示分析表
    void Syntaxanalysis(string analytarget);//语法分析
    bool judgeNT( char ch);
    bool judgeVT( char ch);
};

bool excel::judgeNT(char ch){
    for(auto c:VN)
        if(ch==c)
            return true;
    return false;
}

bool excel::judgeVT(char ch){
    for(auto c:VT)
        if(ch==c)
            return true;
    return false;
}
excel::excel(){
    TT.push_back(set('E',{'d','(','n'},{'s',')'},{"TD"}));
    TT.push_back(set('D',{'+','-','e'},{'s',')'},{"+TD","-TD","e"}));
    TT.push_back(set('T',{'d','(','n'},{'+','-'},{"FB"}));
    TT.push_back(set('B',{'*','/','e'},{'+','-'},{"*FB","/FB","e"}));
    TT.push_back(set('F',{'d','(','n'},{'*','/'},{"d","(E)","n"}));
}


excel::~excel(){
    cout<<"byr"<<endl;
}

void excel::gene(){
    for(auto se:TT){
        for(auto fi:se.first){
            if(fi=='e'){
                for(auto fo:se.follow){
                    analysistable.insert(pair<loc,string>(loc(se.nt,fo),"e"));
                }
            }
            else{
                int choice=0;//choice
                int temp=(int)(se.production).size();
                for(int i=0;i<temp;i++){
                    if(se.production[i][0]==fi){
                        choice=i;
                    }
                }
                analysistable.insert(pair<loc,string>(loc((se.nt),fi),se.production[choice]));
            }
        }
    }
}

string excel::searchgene(char w,char m){
    iter=analysistable.find(loc(w,m));
    cout<<iter->second<<endl;;
    if(iter!=analysistable.end())
        return iter->second;//不能正确返回查询结果
    return "";
    
}
void excel::displaygene(){
    cout<<"\t";
    for(auto t:VT)
        cout<<t<<"\t";
    cout<<endl;
    for(auto p:VN){
        cout<<p<<"\t";
        for(auto q:VT){
            //cout<<searchgene(p,q)<<endl;
            if(searchgene(p,q).length()>0)
                
                cout<<p<<"->"<<searchgene(p,q)<<"\t";
        }
        cout<<endl;
    }
}
void excel::Syntaxanalysis(string analytarget){
    analytarget=analytarget+'s';
    string stak="sE";
    do{
        char X=youzhanding(stak);
        char A=zuozhanding(analytarget);
        if(judgeVT(X))
        {
            if(X==A)
            {
                stak=youtanzhan(stak);
                analytarget=zuotanzhan(analytarget);
            }
            else{
                cout<<"error!"<<endl;
                break;
            }
        }
        else{
            string wtemp=searchgene(X, A);
            if(wtemp.size()>0){
                stak=youtanzhan(stak);
                wtemp=strrev(wtemp);
                stak=youruzhan(stak, wtemp);
                cout<<X<<"->"<<strrev(wtemp)<<endl;
                
            }
            else{
                cout<<"error!"<<endl;
                break;
            }
        }
        
    }while(!(stak=="s"&&analytarget=="s"));
}

int main() {
    excel e;
    return 0;
}

```
    





