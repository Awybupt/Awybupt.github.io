---
layout:     post
title:      Python图像处理
subtitle:   OpenCV
date:       2017-11-23
author:     Awybupt
header-img: img/page-CL.jpg
catalog: true
tags:
    - python
---


### Catalog
* [图像处理概述](#concepts)
* [python图像处理](#py)
* [本题图像处理](#massage)
* [图像处理的数学原理](#math)
* [附录](#addition)

<h3 id='concepts'>图像处理概述</h3>


* 计算机对图像进行分析，以达到所需结果的技术
* 包括以下几个方面
    * 图像获取和输出
    * 图像编码和压缩
    * 图像增强与复原
    * 图像的频域变换
    * 图像的信息安全
    * 图像的区域分割
    * 图像目标的识别
    * 图像的几何变换

<h3 id='py'>python图像处理简介</h3>

* 多数图像处理与操作技术可以被两个库有效完成，它们是Python Imaging Library (PIL)与 OpenSource Computer Vision (OpenCV)
* 安装PIL

```python
    $pip install Pillow
```

* 简单操作

```python 
from PIL import Image, ImageFilter
#读取图像
im = Image.open( 'image.jpg' )
#显示图像
im.show()

#过滤图像
im_sharp = im.filter( ImageFilter.SHARPEN )
#保存过滤过的图像到文件中
im_sharp.save( 'image_sharpened.jpg', 'JPEG' )

#分解图像到三个RGB不同的通道（band）中。
r,g,b = im_sharp.split()

#显示被插入到图像中的EXIF标记
exif_data = im._getexif()
exif_data
```

* OpenSource Computer Vision,其更广为人知的名字是OpenCV，是一个在图像操作与处理上 比PIL更先进的库。它可以在很多语言上被执行并被广泛使用
* 安装numpy,更推荐用Anaconda,集成了许多的包,还有jupyter.

```python
    $pip install numpy
```

* 简单操作

```python 
from cv2 import *
import numpy as np
#读取图像
img = cv2.imread('testimg.jpg')
#显示图像
cv2.imshow('image',img)
cv2.waitKey(0)
cv2.destroyAllWindows()

#Applying Grayscale filter to image 作用Grayscale（灰度）过滤器到图像上
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

#保存过滤过的图像到新文件中
cv2.imwrite('graytest.jpg',gray)
```

<h3 id='massage'>本题中的图像处理</h3>

![qu-yu-image](media/15126377142363/qu-yu-image.png)
* Low-pass Filter
    * 低通滤波
    
* subtract
    * 图像相减
    
* Enhancement
    * 图像增强/锐化
* add
    * 图像加和

    
<h3 id='math'>图像处理的数学原理</h3>

可见原图像的纹理（例如图形环和远处的星辰等）都得到了很好的保护，而噪声也得到了有效的降低。但问题又回来了，wiener2函数到底是如何做到这一切的，其背后的原理是什么呢？
我们引入经典教科书中都会使用的一个图像退化模型，并以此作为算法讨论的开始。如下图所示，输入待处理图像f(x,y)在退化函数H的作用下，由于受到噪声η(x,y)的影响，最终得到一个退化图像g(x,y)。图像复原的过程就是在给定g(x,y)以及关于退化函数H和加性噪声η(x,y)的一些信息后，设法估计出原始图像的近似值f̂ (x,y)。当然，我们期望最终的近似值可以最大限度地逼近原始图像。显然关于H和η的信息掌握得越多，那么最终得到的估计结果就越接近原始图像。

如果H是一个线性移不变系统，那么在时域中给出的退化过程可由如下公式给出：

g(x,y)=h(x,y)∗f(x,y)+η(x,y)
其中，h(x,y)是退化函数在时域下的表示，运算符∗表示时域卷积。由卷积定理可知，时域上的卷积等同于频域上的乘积，所以上式在频域中的表述如下：
G(u,v)=H(u,v)F(u,v)+N(u,v)
其中的大写字母项是之前公式里对应项的傅里叶变换。 

<h3 id='addition'>附录</h3>




